
import FileBuilder
import Foundation

public struct LocalizedKeyGenerator {
    public enum Error: Swift.Error, CustomStringConvertible {
        case keyHasSpaces(_ key: String)
        case couldntGetStringsDictPath(_ fileName: String)
        case couldntLoadStringsDict(_ url: URL)
        
        public var description: String {
            switch self {
            case .keyHasSpaces(let key):
                return "The key '\(key)' contains spaces, which won't work for creating an enum. Please replace spaces with underscores."
            case .couldntGetStringsDictPath(let fileName):
                return "Couldn't get the path to \(fileName).strings, please check your configuration file (or create one)."
            case .couldntLoadStringsDict(let url):
                return "Couldn't load the strings dictionary at \(url)"
            }
        }
    }
    
    private let options: LocalizedKeyOptions
    public init(options: LocalizedKeyOptions) {
        self.options = options
    }
    
    public func generateFileContents(from bundle: Bundle) throws -> String {

        let enumName = self.enumName(from: self.options)
        let accessString = self.publicOrEmpty(from: self.options)
        let fileName = self.fileName(from: self.options)

        guard let localizedStringsDictURL = bundle.url(forResource: fileName, withExtension: "strings") else {
            throw Error.couldntGetStringsDictPath(fileName)
        }
        guard let localizedStringsDict = NSDictionary(contentsOf: localizedStringsDictURL) as? [String: String] else {
            throw Error.couldntLoadStringsDict(localizedStringsDictURL)
        }

        let alphabetizedKeys = localizedStringsDict.map { $0.key }.sorted()

        @TextBuilder func text() -> some Text {

            "/// This file is automatically generated. Any changes will be overwritten."

            Line.empty

            "\(accessString)enum \(enumName): String, CaseIterable {"

            for key in alphabetizedKeys where !key.contains(" ") {
                "case \(key)"
                    .indented()
            }

            Line.empty

            "\(accessString)var localizedValue: String {"
                .indented()

            switch self.options.location {
            case .frameworkBundle:
                """
                LocalizedString(key: self.rawValue,
                                bundle: Bundle(for: ClassForBundleLocation.self),
                                comment: "")
                """
                    .indented()
                    .indented()
                "}".indented()
                "}"
                Line.empty
                "private class ClassForBundleLocation {}"

            case .mainBundle,
                 .none: // assumes main bundle by default
                """
                LocalizedString(key: self.rawValue,
                                bundle: .main,
                                comment: "")
                """
                    .indented()
                    .indented()
                "}".indented()
                "}"

            case .swiftModule:
                """
                LocalizedString(key: self.rawValue,
                                bundle: .module,
                                comment: "")
                """
                    .indented()
                    .indented()
                "}".indented()
                "}"
            }
        }

        return text().indentation(.spaces(2)).content
    }
    
    private func fileName(from options: LocalizedKeyOptions) -> String {
        guard let passedInName = options.fileName else {
            return "Localizable"
        }
        
        return passedInName
    }
    
    
    private func enumName(from options: LocalizedKeyOptions) -> String {
        guard let enumName = options.enumName else {
            return "LocalizedKey"
        }
        
        return enumName
    }
    
    
    private func publicOrEmpty(from options: LocalizedKeyOptions) -> String {
        guard
            let publicOption = options.isPublic,
            publicOption == true else {
            return ""
        }
        
        return "public "
    }
}
